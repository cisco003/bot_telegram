import telebot
import requests
from datetime import datetime, timedelta

# Insert your bot token and OpenWeatherMap API key here
BOT_TOKEN = 'YOUR_TOKEN'
OPENWEATHERMAP_API_KEY = 'YOUR_API'

UNITS='metric'
def get_weather(city):
    """Retrieve weather data for a specific city."""
    unit_symbol = '째C' if UNITS == 'metric' else '째F'
    url = f'https://api.openweathermap.org/data/2.5/weather?q={city}&appid={OPENWEATHERMAP_API_KEY}&units={UNITS}'
    response = requests.get(url)
    data = response.json()

    if data['cod'] != '404':
        weather = data['weather'][0]['description']
        temperature = round(data['main']['temp'], 1)
        feels_like = round(data['main']['feels_like'], 1)
        humidity = data['main']['humidity']

        message = f"""
**Weather for {city}**

* Conditions: {weather}
* Temperature: {temperature}{unit_symbol} (feels like: {feels_like}{unit_symbol})
* Humidity: {humidity}%
        """
        return message
    else:
        return f"City not found: {city}"


def get_forecast(city, units):
    """Retrieve weather forecast for the next 5 days."""
    unit_symbol = '째C' if units == 'metric' else '째F'
    url = f'https://api.openweathermap.org/data/2.5/forecast?q={city}&appid={OPENWEATHERMAP_API_KEY}&units={units}'
    response = requests.get(url)
    data = response.json()

    if data['cod'] != '404':
        forecast = {}
        for item in data['list']:
            date = datetime.fromtimestamp(item['dt'])
            day = date.strftime('%Y-%m-%d')
            if day not in forecast:
                forecast[day] = []
            forecast[day].append({
                'time': date.strftime('%H:%M'),
                'weather': item['weather'][0]['description'],
                'temperature': round(item['main']['temp'], 1)
            })

        message = f"**Weather forecast for the next 5 days in {city}:**\n\n"
        for day, data in forecast.items():
            message += f"**{day}**\n"
            for item in data:
                message += f"- {item['time']}: {item['weather']}, {item['temperature']}{unit_symbol}\n"
            message += "\n"

        return message
    else:
        return f"City not found: {city}"


def handle_command(message):
    """Handle commands received by the bot."""
    text = message.text.lower()

    if text.startswith('/start'):
        bot.reply_to(message, 'Welcome to the weather bot! Send the name of a city to get the weather forecast.')
    elif text.startswith('/meteo'):
        bot.reply_to(message, 'For which city do you want the weather?')
        # Setting state to 'waiting_for_city' to handle subsequent message
        bot.register_next_step_handler(message, get_weather_for_city)
    elif text.startswith('/previsioni'):
        bot.reply_to(message, 'For which city do you want the weather forecast?')
        # Setting state to 'waiting_for_city' to handle subsequent message
        bot.register_next_step_handler(message, get_forecast_for_city)
    elif text.startswith('/deletewebhook'):
        # Delete the webhook using the Telegram API
        delete_webhook_url = f'https://api.telegram.org/bot{BOT_TOKEN}/deleteWebhook'
        response = requests.post(delete_webhook_url)

        if response.json().get('ok'):
            bot.reply_to(message, 'Webhook deleted successfully!')
        else:
            error_message = response.json().get('description', 'An error occurred while deleting the webhook.')
            bot.reply_to(message, error_message)
    elif text.startswith('/help'):
        commands = [
            "/start - Start the bot",
            "/meteo - Get current weather forecast after specifying the city",
            "/previsioni - Get the weather forecast for the next 5 days after specifying the city",
            "/deletewebhook - Delete the webhook (if active)",
            "/help - Show the list of available commands"
        ]
        bot.reply_to(message, "\n".join(commands))
    elif text.startswith('/unit'):
        # Provide options for choosing units
        options = ["Metric", "Imperial"]
        reply_markup = telebot.types.ReplyKeyboardMarkup(resize_keyboard=True)
        reply_markup.add(*options)
        bot.reply_to(message, "Choose unit system:", reply_markup=reply_markup)
        bot.register_next_step_handler(message, process_unit_choice)
    else:
        bot.reply_to(message, 'Command not recognized. Try /start, /meteo <city>, /previsioni <city>, /deletewebhook, or /help to see the list of commands.')


def process_unit_choice(message):
    global UNITS
    unit_choice = message.text.lower()
    if unit_choice == "metric":
        bot.reply_to(message, "You've chosen Metric units.")
        UNITS='metric'
    elif unit_choice == "imperial":
        bot.reply_to(message, "You've chosen Imperial units.")
        UNITS='imperial'
    else:
        bot.reply_to(message, "Invalid choice. Please select either Metric or Imperial.")
    # Store user's unit preference in database or somewhere


def get_weather_for_city(message):
    city = message.text
    # Default to metric if not set
    weather_message = get_weather(city)
    bot.reply_to(message, weather_message)


def get_forecast_for_city(message):
    city = message.text
    # Default to metric if not set
    forecast_message = get_forecast(city)
    bot.reply_to(message, forecast_message)


bot = telebot.TeleBot(BOT_TOKEN)
bot.set_webhook()
bot.register_message_handler(handle_command)

bot.polling()
